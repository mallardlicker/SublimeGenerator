// TextFormatter.cpp
// Author: Justin Bunting
// Created: 2025/10/01
// Last Modified: 2025/10/05 22:57

#include "TextFormatter.h"


#include <string>
#include <iostream>
#include <sstream>
#include <filesystem>
#include <vector>

#include <CppUtils/CppUtils.h>

#include "FileOps.h"

namespace TextFormatter {

    void printTitle(std::string title) {
        std::cout << std::right << "\n\n"
                  << std::setw(int((TEXT_WIDTH - title.length()) / 2) + 1) << std::setfill('-') << "-"
                  << title << std::setw(int((TEXT_WIDTH - title.length()) / 2) + 2) << "-\n\n"
                  << std::setfill(' ');
    }

    void printProject(const Project& prj, std::string title, int param) {

        // temp vars
        std::string tmp = "";
        std::string tmp2 = "";
        std::string tmp3 = "";

        printTitle(title);

        std::cout << std::left;

        if (param == EditParam::Build || param == EditParam::Name) {

            std::cout << std::setw(WIDTH_L) << "\tProject name:" << std::setw(WIDTH_R) << prj.name << " (1)\n";

            if (param == EditParam::Name) {

                tmp = std::string("\tThe name of the project that will be generated by this program. ") +
                      "Specifically, this variable is used in the main CMakeLists.txt file as the project name, as well as in the ._-project/._-workspace files as both the file and project name. " +
                      "By default, the project folder, standalone/app folder (when applicable), and lib/engine folder (when applicable) also use the project name. " +
                      "Warning: this WILL change the project, app, and lib folder names (when applicable)." +
                      "\n\n\tSpecify the project name from command line as a single string (eg. 'pg Taco').";
                wrapText(tmp, TEXT_WIDTH);
                std::cout << "\n"
                          << tmp << "\n";
            }
        }

        if (param == EditParam::Build || param == EditParam::Type) {

            std::cout << std::setw(WIDTH_L) << "\tProject type:" << std::setw(WIDTH_R) << ProjectInfo::pTypeToStr(prj.type) << " (2)\n";
            
            if (param == EditParam::Type) {
                tmp = std::string("\tThe type of project that will be generated by this program. ") +
                        "\n\nProject features: " +
                        "\n\t(a) cpp/include folders in dedicated app/exe/lib folder" +
                        "\n\t(b) generates standalone executable" +
                        "\n\t(c) generates application" +
                        "\n\t(d) generates library" +
                        "\n\t(e) generates engine (private library used by exe/app)" +
                        "\n\t(f) can use external libraries" +
						"\n\t(g) command-line argument used to modify type";
                tmp2 = std::string(
						"\n\n\tProject type\t\t\t") +	"(a)\t\t(b)\t\t(c)\t\t(d)\t\t(e)\t\t(f)\t\t(g)" +
						"\n\t----------------------------------------------------------------------------" +
                        "\n\tBasic\t\t\t\t\t" +         "No \t\tYes\t\tNo \t\tNo \t\tNo \t\tNo \t\t-b" +
                        "\n\tLibrary\t\t\t\t\t" +       "Yes\t\tNo \t\tNo \t\tYes\t\tNo \t\tYes\t\t-l" +
                        "\n\tStandalone\t\t\t\t" +      "Yes\t\tYes\t\tNo \t\tNo \t\tNo \t\tYes\t\t-s" +
                        "\n\tApplication\t\t\t\t" +     "Yes\t\tNo \t\tYes\t\tNo \t\tNo \t\tYes\t\t-a" +
                        "\n\tStandalone & Engine\t\t" + "Yes\t\tYes\t\tNo \t\tNo \t\tYes\t\tYes\t\t-se" +
                        "\n\tApplication & Engine\t" +  "Yes\t\tNo \t\tYes\t\tNo \t\tYes\t\tYes\t\t-ae";
                tmp3 = std::string(
						"\n\n\tWarning: this WILL change all applicable project variables to generator defaults (project name always remains unchanged). ") +
                        "\n\n\tUse command line arguments as inputs for type modification here, or enter the full type name.";
                wrapText(tmp, TEXT_WIDTH);
				wrapText(tmp3, TEXT_WIDTH);
                std::cout << "\n" << tmp << tmp2 << tmp3 << "\n";
            }
        }

        if (param == EditParam::Build) {
          std::cout << "\n";
        }

        if (param == EditParam::Build || param == EditParam::ExeName) {
            
            // Standalone/Application name:
            tmp = std::string((prj.type == PType::Application || prj.type == PType::ApplicationEngine) ? "Application" : "Standalone");
			tmp2 = std::string((prj.type == PType::Application || prj.type == PType::ApplicationEngine) ? ".app" : "");
            std::cout << std::setw(WIDTH_L) << ("\t" + tmp + " name:") << std::setw(WIDTH_R) << (prj.exeName + tmp2) << " (3)\n";
            
            if (param == EditParam::ExeName) {
                
                std::transform(tmp.begin(), tmp.end(), tmp.begin(), ::tolower);
                tmp = std::string("\tThe name of the " + tmp + " that will be generated by this project.");
                wrapText(tmp, TEXT_WIDTH);
                std::cout << "\n" << tmp << "\n";
            }
        }

        if (param == EditParam::Build || param == EditParam::Directory) {

            // TODO: use wrapFilename instead
            // directory splitting
            tmp = prj.directory.string();
            if (tmp.size() >= WIDTH_R) {

                for (int i = WIDTH_R - 1; i > 0; i--) {

                    if (tmp[i] == '/') {

                        tmp2 = tmp.substr(i + 1, tmp.length());
                        tmp = tmp.substr(0, i + 1) + "\n";
                        break;
                    }
                }
                std::cout << std::setw(WIDTH_L) << "\tGen directory:" << std::setw(WIDTH_R) << tmp
                          << std::setw(WIDTH_L) << "\t " << std::right << std::setw(WIDTH_R - 1) << tmp2 << "  (4)\n"
                          << std::left;
            }
            else {

                std::cout << std::setw(WIDTH_L) << "\tGen directory:" << std::setw(WIDTH_R) << tmp << " (4)\n";
            }

            if (param == EditParam::Directory) {

                tmp = std::string("\tThe directory in which the project (folder) will be generated by this program. ") +
                      "Note that the project resources/files will be created within said project folder (not within the gen directory itself)." +
                      "\n\n\tBelow is the current project that will be generated.\n\n";
                wrapText(tmp, TEXT_WIDTH);
                std::cout << "\n" << tmp;
                printProjectFolders(prj);
            }
        }

        if (param == EditParam::Build) {
            std::cout << "\n";
        }

        if (param == EditParam::Build || param == EditParam::ProjectFolder) {

            tmp = "../" + prj.directory.filename().string() + "/" + prj.projectFolder;
            std::cout << std::setw(WIDTH_L) << "\tProject folder:" << std::setw(WIDTH_R) << tmp << " (5)\n";

            if (param == EditParam::ProjectFolder) {

                tmp = std::string("\tThe folder in which the project will be generated by this program (in Directory/ProjectFolder). ") +
                      "This is where the project resources/files will be created." +
                      "\n\n\tBelow is the current project that will be generated.\n\n";
                wrapText(tmp, TEXT_WIDTH);
                std::cout << "\n" << tmp;
                printProjectFolders(prj);
            }
        }

        if (param == EditParam::Build || param == EditParam::AppFolder) {

            // only display app folder if it exists
            tmp = std::string((prj.type == PType::Application || prj.type == PType::ApplicationEngine) ? "App" : "Stl");
            tmp2 = prj.appFolder;
            tmp3 = " (x)\n";
            if (tmp2 != "N/A") {

                tmp2 = "../" + prj.directory.filename().string() + "/" + prj.projectFolder + "/" + tmp2;
                tmp3 = " (6)\n";
            }
            std::cout << std::setw(WIDTH_L) << ("\t" + tmp + " folder:") << std::setw(WIDTH_R) << tmp2 << tmp3;

            if (param == EditParam::AppFolder) {

                tmp = std::string("\tThe folder in which either a standalone or application's resources will be generated (in Directory/ProjectFolder/" + tmp + "Folder). ") +
                      "This includes 'assets', 'cpp', and 'include' folders, along with the CMakeLists.txt file necessary to generate the executable. " +
                      "Also includes 'libraries' folder when generating a standalone/application that does not include an engine." +
                      "\n\n\tBelow is the current project that will be generated.\n\n";
                wrapText(tmp, TEXT_WIDTH);
                std::cout << "\n" << tmp;
                printProjectFolders(prj);
            }
        }

        if (param == EditParam::Build || param == EditParam::LibFolder)
        {

            // only display lib folder if it exists
            tmp = std::string((prj.type == PType::StandaloneEngine || prj.type == PType::ApplicationEngine) ? "Engine" : "Library");
            tmp2 = prj.libFolder;
            tmp3 = " (x)\n";
            if (tmp2 != "N/A")
            {

                tmp2 = "../" + prj.directory.filename().string() + "/" + prj.projectFolder + "/" + tmp2;
                tmp3 = " (7)\n";
            }
            std::cout << std::setw(WIDTH_L) << ("\t" + tmp + " folder:") << std::setw(WIDTH_R) << tmp2 << tmp3;

            if (param == EditParam::LibFolder)
            {

                tmp = std::string("\tThe folder in which either a library or combined application's private library/engine resources will be generated (in Directory/ProjectFolder/" + tmp + "Folder). ") +
                      "This includes 'cpp', 'include', and 'libraries' folders, along with the CMakeLists.txt file necessary to generate the library." +
                      "\n\n\tBelow is the current project that will be generated.\n\n";
                wrapText(tmp, TEXT_WIDTH);
                std::cout << "\n" << tmp;
                printProjectFolders(prj);
            }
        }

        if (param == EditParam::Build)
        {

            // "process" key
            std::cout << std::setw(TEXT_WIDTH - 6) << "\n\t-> " + std::string(prj.isGenerated ? "Edit" : "Generate") + " Project" << " (0)\n";
            // std::cout << std::setw(TEXT_WIDTH - 6) << "\n\t-> " + std::string(prj.isGenerated ? "Edit" : "Generate") + " Project" << " (0)\n";
        }

        // separator (-----)
        std::cout << "\n"
                  << std::setw(TEXT_WIDTH) << std::setfill('-') << "-" << std::setfill(' ') << std::endl;
                //   << std::setw(TEXT_WIDTH) << std::setfill('-') << "-" << std::setfill(' ') << std::endl;
    }

    void printProjectFolders(const Project &prj) {
        
        // create left text
        std::string left = "";
        left.append(int(WIDTH_L / 4), '\t');
        left.append(WIDTH_L % 4, ' ');
        
        // get correct directory in assets
        std::filesystem::path assetsDir = "/Users/mallardlicker/scripts/C++/SublimeProjects/SublimeGenerator/SublimeGenerator/assets";
	    assetsDir = assetsDir / ProjectInfo::pTypeToStr(prj.type, true);
        
        // print root text
        std::string root = prj.directory.string();
        wrapFileName(root, TEXT_WIDTH);
        std::cout << "\n" << root << std::endl;
        
        // print folder tree text
        printFolderTree(assetsDir, prj, left, true);
    }
    
    void printFolderTree(std::filesystem::path &path, const Project &prj, const std::string &prefix, bool isLast) {
        
        // check name for "Basic" etc --> convert to sg things
        std::string name = path.filename().string();
        if (name.find(".DS_Store") != std::string::npos) { return; } // ensure that this is a file we would like to print
        if (ProjectInfo::strToPType(name) != PType::None) {
            
            name = "sgName";
        }
        // replace all pg__ terms
        FileOps::searchReplacePrjTerms(name, prj);
        
        // print current file/folder
        std::cout << prefix << (isLast ? "└── " : "├── ") << name << "\n";
        
        // only use recursion if this is a folder
        if (CppUtils::File::isDirectory(path)) {
            
            // loop through folders first, then files
            std::vector<std::filesystem::path> dir;
            for (std::filesystem::path &p : CppUtils::File::getFoldersInDir(path)) {
                dir.push_back(p);
            }
            for (std::filesystem::path &p : CppUtils::File::getFilesInDir(path)) {
                dir.push_back(p);
            }
            for (int i = 0; i < dir.size(); i++) {
                
                bool last = (i == dir.size() - 1);
                
                // get (append) child prefix
                std::string childPrefix = prefix + (isLast ? "    " : "│   ");
                
                printFolderTree(dir[i], prj, childPrefix, last);
            }
        }
    }
    
    void wrapText(std::string &text, int textWidth, int indentL, int indentR) {

        // output text and streamed text
        std::string tmpText = "";
        std::string left = "";
        left.append(int(indentL / 4), '\t');
        left.append(indentL % 4, ' ');
        tmpText.append(left);
        std::stringstream s(text);

        // tracking variables
        std::string word;
        std::string btwStr;
        int lastPos = 0;
        int pos;
        int lineLength = indentL;

        while (s >> word)
        {

            // Use previous word and current word start to determine characters between
            pos = text.find(word, lastPos);
            btwStr = text.substr(lastPos, pos - lastPos);

            // Include tabs and newlines in length considerations
            for (char c : btwStr)
            {

                switch (c)
                {
                case ' ':
                    break;
                case '\t':
                    lineLength += int(lineLength / 4) * 4 + 4;
                    tmpText = tmpText + '\t';
                    break;
                case '\n':
                    lineLength = indentL;
                    tmpText = tmpText + '\n';
                    tmpText.append(left);
                    break;
                }
            }

            if (lineLength + word.length() > textWidth - indentR)
            {

                // start new line
                lineLength = indentL;
                tmpText = tmpText + '\n';
                tmpText.append(left);
            }

            // Always add word length and space length to total line length
            lineLength += word.length() + 1;
            tmpText = tmpText + word + " ";

            lastPos = pos + word.length();
        }

        text = tmpText;
    }
    
    void wrapFileName(std::string& fileText, int textWidth, int indentAfterBreak, int indentL, int indentR) {
        
        int* breaks = new int[4]; // max 4 breaks
        int j = 0;
        int zero = 0;
        int prev = 0;
        
        // find and track which '/''s should break/wrap
        for (int i = 0; i < fileText.length(); i++)
        {
            if (fileText[i] == '/') {
                
                // when a '/' is found beyond the textWidth, want to break at the previous '/'
                if (i - zero >= textWidth - indentL - indentR - (j > 0 ? indentAfterBreak : 0)) {

                    breaks[j++] = prev;
                    zero = prev + 1;
                }
                
                // store the last '/' location
                prev = i;
            }
        }
        
        std::string tmpText = "\n";
        std::string left = "\n";
        left.append(int((indentL + indentAfterBreak) / 4), '\t');
        left.append((indentL + indentAfterBreak) % 4, ' ');

        // reformat text
        while (j > 0) {
            tmpText = left + fileText.substr(j+1, fileText.length()) + tmpText;
            fileText = fileText.substr(0, j+1);
            j--;
        }
        
        left = "";
        left.append(int(indentL / 4), '\t');
        left.append(indentL % 4, ' ');
        
        fileText = left + fileText + tmpText;
    }
    
}