// TextFormatter.cpp
// Author: Justin Bunting
// Created: 2025/10/01
// Last Modified: 2025/10/01 11:39

#include "TextFormatter.h"


#include <iostream>
#include <sstream>

#include "Project.h"

namespace TextFormatter {

    static void printTitle(std::string title) {
        std::cout << std::right << "\n\n"
                  << std::setw(int((TEXT_WIDTH - title.length()) / 2) + 1) << std::setfill('-') << "-"
                  << title << std::setw(int((TEXT_WIDTH - title.length()) / 2) + 2) << "-\n\n"
                  << std::setfill(' ');
    }

    static void printProject(const Project& prj, std::string title, int param) {

        // sizing and temp vars
        int widthL = TEXT_WIDTH / 5 - 2;
        int widthL = TEXT_WIDTH / 5 - 2;
        int widthR = TEXT_WIDTH / 5 * 4 - 5;
        int widthR = TEXT_WIDTH / 5 * 4 - 5;
        std::string tmp = "";
        std::string tmp2 = "";

        TextFormatter::printTitle(title);

        std::cout << std::left;

        if (param == 0 || param == 1)
        {

            std::cout << std::setw(widthL) << "\tProject name:" << std::setw(widthR) << prj.name << " (1)\n";

            if (param == 1)
            {

                tmp = std::string("\tThe name of the project that will be generated by this program. ") +
                      "Specifically, this variable is used in the main CMakeLists.txt file as the project name, as well as in the .sublime-project file as both the file and project name. " +
                      "By default, the project folder and app folder (when applicable) also use the project name. " +
                      "Warning: this WILL change the project, app, and library folder names (when applicable)." +
                      "\n\n\tSpecify the project name from command line as a single string (eg. 'Taco').";
                wrapText(tmp, TEXT_WIDTH);
                std::cout << "\n"
                          << tmp << "\n";
            }
        }

        if (param == 0 || param == 2)
        {

            std::cout << std::setw(widthL) << "\tProject type:" << std::setw(widthR) << ProjectInfo::pTypeToStr(prj.type) << " (2)\n";
            
            if (param == 2)
            {

                tmp = std::string("\tThe type of project that will be generated by this program. ") +
                      "Basic projects involve only the cpp and include folders, and generate a simple executable. " +
                      "Standalone projects are for app creation that may involve external libraries. " +
                      "Library is a project type that is meant for custom library creation, and may include external libraries. " +
                      "Application & Engine combines the Standalone and Library types into one, in which both an app and 'engine' (custom library) are built. " +
                      "Warning: this WILL change the project, app, and library folder names (when applicable). " +
                      "\n\n\tUse -b, -s, -l, and -a as command line arguments (setting to Basic, Standalone, Library, and Application & Engine respectively).";
                wrapText(tmp, TEXT_WIDTH);
                std::cout << "\n"
                          << tmp << "\n";
            }
        }

        if (param == 0)
        {
            std::cout << "\n";
        }

        if (param == 0 || param == 3)
        {

            std::cout << std::setw(widthL) << "\tExecutable name:" << std::setw(widthR) << prj.exeName << " (3)\n";

            if (param == 3)
            {

                tmp = std::string("\tThe name of the executable that will be generated by this project.");
                wrapText(tmp, TEXT_WIDTH);
                std::cout << "\n"
                          << tmp << "\n";
            }
        }

        if (param == 0 || param == 4)
        {

            // directory splitting
            tmp = prj.directory.string();
            if (tmp.size() >= widthR)
            {

                for (int i = widthR - 1; i > 0; i--)
                {

                    if (tmp[i] == '/')
                    {

                        tmp2 = tmp.substr(i + 1, tmp.length());
                        tmp = tmp.substr(0, i + 1) + "\n";
                        break;
                    }
                }

                std::cout << std::setw(widthL) << "\tGen directory:" << std::setw(widthR) << tmp
                          << std::setw(widthL) << "\t " << std::right << std::setw(widthR - 1) << tmp2 << "  (4)\n"
                          << std::left;
            }
            else
            {

                std::cout << std::setw(widthL) << "\tGen directory:" << std::setw(widthR) << tmp << " (4)\n";
            }

            if (param == 4)
            {

                tmp = std::string("\tThe directory in which the project (folder) will be generated by this program. ") +
                      "Note that the project resources/files will be created within said project folder (not within the directory itself).";
                wrapText(tmp, TEXT_WIDTH);
                std::cout << "\n"
                          << tmp << "\n";
            }
        }

        if (param == 0)
        {
            std::cout << "\n";
        }

        if (param == 0 || param == 5)
        {

            tmp = "../" + prj.directory.filename().string() + "/" + prj.projectFolder;
            std::cout << std::setw(widthL) << "\tProject folder:" << std::setw(widthR) << tmp << " (5)\n";

            if (param == 5)
            {

                tmp = std::string("\tThe folder in which the project will be generated by this program (in Directory/ProjectFolder). ") +
                      "This is where the project resources/files will be created.";
                wrapText(tmp, TEXT_WIDTH);
                std::cout << "\n"
                          << tmp << "\n";
            }
        }

        if (param == 0 || param == 6)
        {

            // only display app folder if it exists
            tmp = prj.appFolder;
            tmp2 = " (x)\n";
            if (tmp != "N/A")
            {

                tmp = "./" + prj.projectFolder + "/" + tmp;
                tmp2 = " (6)\n";
            }
            std::cout << std::setw(widthL) << "\tApp folder:" << std::setw(widthR) << tmp << tmp2;

            if (param == 6)
            {

                tmp = std::string("\tThe folder in which either a standalone or combined application's resources will be generated (in Directory/ProjectFolder/AppFolder). ") +
                      "This includes 'assets', 'cpp', and 'include' folders, along with the CMakeLists.txt file necessary to generate the executable. " +
                      "Also includes 'libraries' folder when generating standalone application.";
                wrapText(tmp, TEXT_WIDTH);
                std::cout << "\n"
                          << tmp << "\n";
            }
        }

        if (param == 0 || param == 7)
        {

            // only display lib folder if it exists
            tmp = prj.libFolder;
            tmp2 = " (x)\n";
            if (tmp != "N/A")
            {

                tmp = "./" + prj.projectFolder + "/" + tmp;
                tmp2 = " (7)\n";
            }
            std::cout << std::setw(widthL) << "\tLibrary folder:" << std::setw(widthR) << tmp << tmp2;

            if (param == 7)
            {

                tmp = std::string("\tThe folder in which either a library or combined application's private library/engine resources will be generated (in Directory/ProjectFolder/LibFolder). ") +
                      "This includes 'cpp', 'include', and 'libraries' folders, along with the CMakeLists.txt file necessary to generate the library.";
                wrapText(tmp, TEXT_WIDTH);
                std::cout << "\n"
                          << tmp << "\n";
            }
        }

        if (param == 0)
        {

            // "process" key
            std::cout << std::setw(TEXT_WIDTH - 6) << "\n\t-> " + std::string(prj.isGenerated ? "Edit" : "Generate") + " Project" << " (0)\n";
            // std::cout << std::setw(TEXT_WIDTH - 6) << "\n\t-> " + std::string(prj.isGenerated ? "Edit" : "Generate") + " Project" << " (0)\n";
        }

        // separator (-----)
        std::cout << "\n"
                  << std::setw(TEXT_WIDTH) << std::setfill('-') << "-" << std::setfill(' ') << std::endl;
                //   << std::setw(TEXT_WIDTH) << std::setfill('-') << "-" << std::setfill(' ') << std::endl;
    }

    static inline bool isNotAlnumSpace(const char &c) {

        // list of allowed characters (letters, numbers, and spaces)
        return !(isalpha(c) || isdigit(c) || (c == ' '));
    }
    
    // static void wrapText(std::string &text, int textWidth, int indentL, int indentR) {
    static void wrapText(std::string &text, int textWidth, int indentL, int indentR) {

        // output text and streamed text
        std::string tmpText = "";
        tmpText.append(int(indentL / 4), '\t');
        tmpText.append(indentL % 4, ' ');
        std::stringstream s(text);

        // tracking variables
        std::string word;
        std::string btwStr;
        int lastPos = 0;
        int pos;
        int lineLength = indentL;

        while (s >> word)
        {

            // Use previous word and current word start to determine characters between
            pos = text.find(word, lastPos);
            btwStr = text.substr(lastPos, pos - lastPos);

            // Include tabs and newlines in length considerations
            for (char c : btwStr)
            {

                switch (c)
                {
                case ' ':
                    break;
                case '\t':
                    lineLength += int(lineLength / 4) * 4 + 4;
                    tmpText = tmpText + '\t';
                    break;
                case '\n':
                    lineLength = indentL;
                    tmpText = tmpText + '\n';
                    tmpText.append(int(indentL / 4), '\t');
                    tmpText.append(indentL % 4, ' ');
                    break;
                }
            }

            if (lineLength + word.length() > textWidth - indentR)
            {

                // start new line
                lineLength = indentL;
                tmpText = tmpText + '\n';
                tmpText.append(int(indentL / 4), '\t');
                tmpText.append(indentL % 4, ' ');
            }

            // Always add word length and space length to total line length
            lineLength = lineLength + word.length() + 1;
            tmpText = tmpText + word + " ";

            lastPos = pos + word.length();
        }

        text = tmpText;
    }
    
    
}